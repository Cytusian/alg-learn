# 贪心思想

## 第455题

[分发饼干](https://leetcode-cn.com/problems/assign-cookies/description/)

```javascript
var findContentChildren = function (g, s) {
  // 对两个数组进行排序
  let arrg = g.sort((a, b) => a - b);
  let arrs = s.sort((a, b) => a - b);
  let j = 0;
  // 饼干最大值都无法满足小孩最小值时，直接返回0
  if (arrg[0] > arrs[arrs.length - 1]) {
    return 0;
  }
  // 逐个遍历饼干，从最小的小孩开始满足
  for (let i = 0; i < s.length && j < g.length; i++) {
    // 满足则开始匹配下一个小孩
    if (arrs[i] >= arrg[j]) {
      j++;
    }
  }
  // 返回满足了的小孩数量
  return j;
};
```

## 第435题

[无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/description/)

```javascript
var eraseOverlapIntervals = function(intervals) {
  let num = 0;
  // 给所有区间段按从小到大排序，按区间起点排序，起点相同则按终点排序
  let arr = intervals.sort((a, b) => {
    return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
  });
  // 遍历所有区间段，遍历结束位置
  for (let i = 0; i + 1 < arr.length; i++) {
    // 前一个区间段起点等于后一个区间段起点时，表示后一个区间段包含前一个区间段
    // 因为已经给区间段排序，所以删除后一个范围大的区间段
    if (arr[i][0] === arr[i + 1][0]) {
      arr.splice(i + 1, 1);
      // 删除后判定指针减1，使得循环的指针加1后指针不变
      i--;
      num++;
    } else if (arr[i][1] > arr[i + 1][0]) {
      // 前一个区间段的终点大于后一个区间段的起点时，表示两个区间段相交，分两种情况
      // 当前一个区间段的终点大于等于后一个区间段的终点时，表示前一个区间段包含后一个区间段
      // 删除前一个区间段
      if (arr[i][1] >= arr[i + 1][1]) {
        arr.splice(i, 1);
        i--;
        num++;
      } else {
        // 当前一个区间段的终点小于后一个区间段的终点时，表示仅相交
        // 删除后一个区间段
        arr.splice(i + 1, 1);
        i--;
        num++;
      }
    }
  }
  return num;
};
```
